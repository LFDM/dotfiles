snippet "^#!" "#!/usr/bin/env ruby" r
#!/usr/bin/env ruby
$0
endsnippet


snippet "^# ?[uU][tT][fF]-?8" "# encoding: UTF-8" r
# encoding: UTF-8
$0
endsnippet



snippet If "<command> if <expression>"
${1:command} if ${0:expression}
endsnippet



snippet Unless "<command> unless <expression>"
${1:command} unless ${0:expression}
endsnippet


snippet tern "ternary operator"
${1:condition} ? ${2:true} : ${0:false}
endsnippet


snippet if "if <condition> ... end"
if ${1:condition}
	${2}
end
endsnippet



snippet ife "if <condition> ... else ... end"
if ${1:condition}
	${2}
else
	${3}
end
endsnippet



snippet ifee "if <condition> ... elseif <condition> ... else ... end"
if ${1:condition}
	${2}
elsif ${3:condition}
	${4}
else
	${0}
end
endsnippet



snippet unless "unless <condition> ... end"
unless ${1:condition}
	${0}
end
endsnippet



snippet unlesse "unless <condition> ... else ... end"
unless ${1:condition}
	${2}
else
	${0}
end
endsnippet



snippet unlesee "unless <condition> ... elseif <condition> ... else ... end"
unless ${1:condition}
	${2}
elsif ${3:condition}
	${4}
else
	${0}
end
endsnippet



snippet "\b(de)?f" "def <name>..." r
def ${1:function_name}
  ${0}	
end
endsnippet

snippet "\b(de)?fa" "def <name>..." r
def ${1:function_name}(${2:*args})
  ${0}	
end
endsnippet

snippet title "Titelize in the Transformation"
${1:a text}
${1/\w+\s*/\u$0/g}
endsnippet



snippet defi "def initialize ..."
def initialize(${1:*args})
	${2:iva}
end
${0}
endsnippet


snippet defr "def <name> ... rescue ..."
def ${1:function_name}${2: ${3:*args}}
	${4}
rescue
	${0}
end
endsnippet



snippet For "(<from>..<to>).each { |<i>| <block> }"
(${1:from}..${2:to}).each { |${3:i}| ${4} }
endsnippet



snippet for "(<from>..<to>).each do |<i>| <block> end"
(${1:from}..${2:to}).each do |${3:i}|
	${0}
end
endsnippet



snippet "(\S+)\.Merge!" ".merge!(<other_hash>) { |<key>,<oldval>,<newval>| <block> }" r
`!p snip.rv=match.group(1)`.merge!(${1:other_hash}) { |${2:key},${3:oldval},${4:newval}| ${5:block} }
endsnippet



snippet "(\S+)\.merge!" ".merge!(<other_hash>) do |<key>,<oldval>,<newval>| <block> end" r
`!p snip.rv=match.group(1)`.merge!(${1:other_hash}) do |${2:key},${3:oldval},${4:newval}|
	${0:block}
end
endsnippet



snippet "(\S+)\.Del(ete)?_?if" ".delete_if { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.delete_if { |${1:key},${2:value}| ${3} }
endsnippet



snippet "(\S+)\.del(ete)?_?if" ".delete_if do |<key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.delete_if do |${1:key},${2:value}|
	${0}
end
endsnippet



snippet "(\S+)\.Keep_?if" ".keep_if { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.keep_if { |${1:key},${2:value}| ${3} }
endsnippet



snippet "(\S+)\.keep_?if" ".keep_if do <key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.keep_if do |${1:key},${2:value}|
	${0}
end
endsnippet



snippet "(\S+)\.Reject" ".reject { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.reject { |${1:key},${2:value}| ${3} }
endsnippet



snippet "(\S+)\.reject" ".reject do <key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.reject do |${1:key},${2:value}|
	${0}
end
endsnippet



snippet "(\S+)\.Select" ".select { |<item>| <block>}" r
`!p snip.rv=match.group(1)`.select { |${1:item}| ${2:block} }
endsnippet



snippet "(\S+)\.select" ".select do |<item>| <block> end" r
`!p snip.rv=match.group(1)`.select do |${1:item}|
	${0:block}
end
endsnippet



snippet "(\S+)\.Sort" ".sort { |<a>,<b>| <block> }" r
`!p snip.rv=match.group(1)`.sort { |${1:a},${2:b}| ${3} }
endsnippet



snippet "(\S+)\.sort" ".sort do |<a>,<b>| <block> end" r
`!p snip.rv=match.group(1)`.sort do |${1:a},${2:b}|
	${0}
end
endsnippet



snippet "(\S+)\.Each_?k(ey)?" ".each_key { |<key>| <block> }" r
`!p snip.rv=match.group(1)`.each_key { |${1:key}| ${2} }
endsnippet



snippet "(\S+)\.each_?k(ey)?" ".each_key do |key| <block> end" r
`!p snip.rv=match.group(1)`.each_key do |${1:key}|
	${0}
end
endsnippet



snippet "(\S+)\.Each_?val(ue)?" ".each_value { |<value>| <block> }" r
`!p snip.rv=match.group(1)`.each_value { |${1:value}| ${2} }
endsnippet



snippet "(\S+)\.each_?val(ue)?" ".each_value do |<value>| <block> end" r
`!p snip.rv=match.group(1)`.each_value do |${1:value}|
	${0}
end
endsnippet



snippet Each "<elements>.each { |<element>| <block> }"
${1:elements}.each { |${2:${1/s$//}}| ${3} }
endsnippet



snippet each "<elements>.each do |<element>| <block> end"
${1:elements}.each do |${2:${1/s$//}}|
	${0}
end
endsnippet



snippet each_?s(lice)? "<array>.each_slice(n) do |slice| <block> end"
each_slice(${1:2}) do |${2:slice}|
	${0}
end
endsnippet



snippet Each_?s(lice)? "<array>.each_slice(n) { |slice| <block> }"
each_slice(${1:2}) { |${2:slice}| ${3} }
endsnippet




snippet "(\S+)\.Map" ".map { |<element>| <block> }" r
`!p snip.rv=match.group(1)`.map { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}| ${2} }
endsnippet



snippet "(\S+)\.map" ".map do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.map do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}|
	${0}
end
endsnippet



snippet "(\S+)\.Rev(erse)?_?each" ".reverse_each { |<element>| <block> }" r
`!p snip.rv=match.group(1)`.reverse_each { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}| ${2} }
endsnippet



snippet "(\S+)\.rev(erse)?_?each" ".reverse_each do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.reverse_each do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}|
	${0}
end
endsnippet



snippet "(\S+)\.Each" ".each { |<element>| <block> }" r
`!p snip.rv=match.group(1)`.each { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}| ${2} }
endsnippet



snippet "(\S+)\.each" ".each do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.each do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}|
	${0}
end
endsnippet




snippet "(\S+)\.Each_w(ith)?_?i(ndex)?" ".each_with_index { |<element>,<i>| <block> }" r
`!p snip.rv=match.group(1)`.each_with_index { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`},${2:i}| ${3} }$0
endsnippet



snippet "(\S+)\.each_?w(ith)?_?i(ndex)?" ".each_with_index do |<element>,<i>| <block> end" r
`!p snip.rv=match.group(1)`.each_with_index do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`},${2:i}|
	${0}
end
endsnippet




snippet "(\S+)\.Each_?p(air)?"  ".each_pair { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.each_pair { |${1:key},${2:value}| ${3} }
endsnippet



snippet "(\S+)\.each_?p(air)?" ".each_pair do |<key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.each_pair do |${1:key},${2:value}|
	${0}
end
endsnippet



snippet "(\S+)\.sub" ".sub(<expression>) { <block> }" r
`!p snip.rv=match.group(1)`.sub(${1:expression}) { ${2:"replace_with"} }
endsnippet



snippet "(\S+)\.gsub" ".gsub(<expression>) { <block> }" r
`!p snip.rv=match.group(1)`.gsub(${1:expression}) { ${2:"replace_with"} }
endsnippet



snippet "(\S+)\.index" ".index { |item| <block> }" r
`!p snip.rv=match.group(1)`.index { |${1:item}| ${2:block} }
endsnippet



snippet "(\S+)\.Index" ".index do |item| ... end" r
`!p snip.rv=match.group(1)`.index do |${1:item}|
	${0:block}
end
endsnippet

# comments about do and dov see snippets/ruby.snippets
snippet do "do ... end" i
do
	$0
end
endsnippet

snippet dov "do |<key>| ... end" i
do |${1:v}|
	$2
end
endsnippet



snippet until "until <expression> ... end"
until ${1:expression}
	${0}
end
endsnippet



snippet Until "begin ... end until <expression>"
begin
	${0}
end until ${1:expression}
endsnippet



snippet wh "while <expression> ... end"
while ${1:expression}
	${0}
end
endsnippet



snippet While "begin ... end while <expression>"
begin
	${0}
end while ${1:expression}
endsnippet



snippet begin "begin ... rescue ... end"
begin
	${1}
rescue
	${0}
end
endsnippet



snippet begine "begin ... rescue ... else ... ensure ... end"
begin
	${1:# Raise exception}
rescue Exception => e
	puts e.message
	puts e.backtrace.inspect
	${2:# Rescue}
else
	${3:# other exception}
ensure
	${0:# always excute}
end
endsnippet



snippet rescue
rescue Exception => e
	puts e.message
	puts e.backtrace.inspect
	${0:# Rescue}
endsnippet

snippet "\b(case|sw(itch)?)" "case <variable> when <expression> ... end" r
case ${1:variable}
when ${2:expression}
  $0
end
endsnippet



snippet alias "alias :<new_name> :<old_name>"
alias :${1:new_name} :${2:old_name}
endsnippet


#snippet class "class <class_name> def initialize ... end end"
#class ${1:class_name}
	#def initialize ${2:*args}
		#$0
	#end
#end
#endsnippet

#snippet module "module"
#module ${1:module_name}
	#$0
#end
#endsnippet


#snippet ###
#=begin
  #$0
#=end
#endsnippet

#####################
#  Customiztations  #
#####################

snippet asloop "ArrayScanner loop"
loop do
  ${0}
  break if ${1:as}.eoa?
end
endsnippet


######### Case statements #########
	
snippet caset "Case with one line when then"
case ${1:obj}
when ${2:cond} then ${3:res}
${0:whent}
end
endsnippet

snippet whent "More when then lines"
when ${1:cond} then ${2:res}
${3:whent}
endsnippet

######### Instance variables #########
	
snippet iva "Instance variable assignment with mirroring"
@${1:iva} = $1
${0}
endsnippet

snippet iv "Plain instance variable assignment"
@${1} = ${0}
endsnippet

######### Concerning Hashes #########

snippet eawodh "each_with_object coming from hash"
each_with_object(${1}) do |(${2:k}, ${3:v}), ${4:v}|
  ${0}
end
endsnippet

snippet "ml?h" "multiline hash" r
${1:var} = {
  ${0}
}
endsnippet

snippet "(hr|:)" "hashrocket" r
'${1}' => ${2},
${0:hr}
endsnippet

######### File Handling #########
	
snippet fexp "Expand file path"
File.expand_path(${1}, ${2:__FILE__})${0}
endsnippet

snippet fr "read a file"
File.read("${1}")${0}
endsnippet

snippet "fod?" "file open with do end block" r
File.open(${1}, '${2}') do
  ${0}
end
endsnippet


######### RSpec #########

snippet spec "sets up a spec file"
require 'spec_helper'

describe ${1} do
  ${0}
end
endsnippet

snippet specm "sets up a spec file to test a module"
require 'spec_helper'

describe ${1} do
  let(:dummy) { Class.new { include $1 }.new }

  ${0}
end
endsnippet

snippet specc "sets up a spec file to test a class"
require 'spec_helper'

describe ${1} do
  let(:${2}) { $1.new${3} }

  ${0}
end
endsnippet

snippet "desc(c)?" "describe block for an instance or class method" !br
describe "`!p snip.rv = '.' if match.group(1) == 'c' else '#'`${1:method}" do
	${0:pending "not implemented"}
end
endsnippet

snippet "cont?" "context with possibility of resuming with example" r
context "${1}" do
  ${0:it}
end
endsnippet

snippet "it" "rspec example with repetition" br
it "${1}" do
  ${2}
end

${0:it}
endsnippet

snippet stub "stubs a message with a block"
stub(:${1}) { ${0} }
endsnippet

snippet stubd "stubs a message with a do end block" 
stub(:${1}) do
  ${0}
end
endsnippet

snippet stubw "stubs message with explicit arguments" 
stub(:${1}).with(${2}) { ${0} }
endsnippet

snippet stubwd "stubs message with explicit arguments and do end block"
stub(:${1}).with(${2}) do
  ${0}
end
endsnippet

snippet dou "launches a spec double"
obj = double(${1})
${0}
endsnippet

snippet "capt?u?r?e?" "captures $stdout in spec files" r
before :all do
  string_io = StringIO.new
  @stdout = $stdout
  $stdout = string_io
end

${0}

after :all do
  $stdout = @stdout
end
endsnippet

snippet outr "what $stdout receives"
  $stdout.should receive(:${1:puts})
endsnippet

snippet outrw "what $stdout receives explicitly"
  $stdout.should receive(:puts).with(/${0}/)
endsnippet

### Class level snippets

snippet "clas?s?" "A class with optional intialize" rb
class ${1}
  ${2:defi}
end
endsnippet

snippet "scla?s?s?" "Switches context to singleton class" rb
class << self
  ${0:def}
end
endsnippet

snippet modc "Module with class and instance methods"
module ${1}
  def self.included(obj)
    obj.extend(ClassMethods)
  end

  ${0}

  module ClassMethods
  end
end
endsnippet

snippet inc "Include with optional repetition"
include ${1}
${0:inc}
endsnippet

snippet "pri?v?a?" "make the rest private" br
private

${0}
endsnippet

snippet "\br" "attr_reader" r
attr_reader :${0:attr_names}
endsnippet

snippet w "attr_writer" b
attr_writer :${0:attr_names}
endsnippet

snippet rw "attr_accessor" b
attr_accessor :${0:attr_names}
endsnippet

snippet atp "attr_protected" b
attr_protected :${0:attr_names}
endsnippet

snippet ata "attr_accessible" b
attr_accessible :${0:attr_names}
endsnippet

######### LLT Snippets #########
	
snippet llt "the llt module" 
module LLT
  ${0}
end
endsnippet

snippet lltc "llt module with a class"
module LLT
  class ${1}
    ${2:defi}
  end
end
endsnippet

snippet lltm "lltc module with another module"
module LLT
  module ${1}
    ${0}
  end
end
endsnippet

######### Regexp helpers #########
	
snippet lb "look-behind"
(?<=${1})${0}
endsnippet

snippet nlb "negative look-behind"
(?<!${1})${0}
endsnippet

snippet la "look-ahead" 
(?=${1})${0}
endsnippet

snippet nla "negative look-ahead"
(?!${1})${0}
endsnippet

snippet ma "match method"
match(/${0}/)
endsnippet

snippet mab "match method with beginning and end (^$)"
match(/^${0}$/)
endsnippet

snippet rbe "regular expression beginning and end (^$"
/^${0}$/
endsnippet

######### Rake #########
	
snippet "ta?sk" "rake task" !br
desc '${1}'
task :${2} do
  ${0}
end
endsnippet

snippet "ta?ska" "rake task with arguments" !br
desc '${1}'
task :${2} do |t, args|
  ${0}
end
endsnippet

snippet ns "rake namespace" !b
namespace :${1} do
  ${0}
end
endsnippet

######### Gemfile #########
	
snippet gem "a gem chain" !b
gem '${1}'
${0:gem}
endsnippet

snippet gemg "git gem git" !b
gem '${1}', git: 'git://github.com/${2}/${3}.git'
${0:gemg}
endsnippet

snippet geml "local gem" !b
gem '${1}', path: '${2}'
${0:geml}
endsnippet

snippet gemr "gem with a require statement" !b
gem '${1}', require: ${2}
${0:gemr}
endsnippet

snippet "gemp([rj])?" "Platform dependent gem" !br
gem '${1}', platform: :`!p snip.rv =  'j' if match.group(1) == 'j' else ''`ruby
endsnippet

snippet "pl([rj])?" "Platform block" !br
platform :`!p snip.rv =  'j' if match.group(1) == 'j' else ''`ruby do
  ${0:gem}
end
endsnippet

######### Thor #########

snippet mo "method_option with an alias and repetition" !b
method_option :${1}, aliases: '-${1/(\w).*/$1/}'
${0:mo}
endsnippet

snippet "thorc?" "a full Thor command" !br
desc '${1}', '${2}'
${4:mo}
def $1(${3:var})
end
endsnippet
	


### ENV vars
snippet env "env variable access"
ENV['${1}']${0}
endsnippet

snippet envh "HOME env var"
ENV['HOME']${0}
endsnippet


######### Requiring #########

snippet req "simple require with repetition" !b
require '${1}'
${0:req}
endsnippet

snippet reqr "require relative with repetition" !b
require_relative '${1}'
${0:reqr}
endsnippet

######### Sinatra #########

snippet "sina?t?r?a?" "modular sinatra" !br
require 'sinatra/base'

class ${1} < Sinatra::Base
  ${0}
end
endsnippet

snippet sget
get '/${1}' do
  ${0}
end
endsnippet

######### Param and options handling #########

snippet p "accessing params" !b
params[:${1}]${0}
endsnippet	

snippet o "accessing options" !b
options[:${1}]${0}
endsnippet

# vim: set ts=2 sw=2 expandtab:
