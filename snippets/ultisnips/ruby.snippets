#############################
#  Custom Snippets by LFDM  #
#############################

######### Global Snippets #########

global !p
def insert_creator_return(snip, first_line, body, end_line, body_indent):
	snip.rv = first_line
	snip >> body_indent
	for line in body:
		snip += line
	snip.reset_indent()
	snip += end_line

def split_body(body):
	return body.split(' . ')

def lhs_and_rhs(line):
	return line.split('  ') if '  ' in line else [line, '']

def hash_creator(var, args, opts, snip):
	first_line = (var.upper() if 'c' in opts else var) + ' = {'
	lines = split_body(args)
	body = []
	delim = ' => ' if 'i' in opts or 's' in opts else ': '
	for line in lines:
		lhs, rhs = lhs_and_rhs(line)
		lhs = "'%s'" % lhs if 's' in opts else lhs
		body.append(lhs + delim + rhs + ',')

	insert_creator_return(snip, first_line, body, '}', 1)

def case_creator(obj, args, snip):
	when_lines, else_line = args.split(' .. ') if ' .. ' in args else [args, '']
	when_lines = split_body(when_lines)
	body = []
	for line in when_lines:
		lhs, rhs = lhs_and_rhs(line)
		body.append('when %s then %s' % (lhs, rhs))
	body.append('else ' + else_line) if else_line else None
	
	insert_creator_return(snip, 'case ' + obj, body, 'end', 0)

def spec_class_name(snip, path, re):
	path_parts = path.split('/')
	path_parts = [part for part in path_parts if not re.match('^(spec|lib)$', part)]
	corrected_parts = []
	for part in path_parts:
		if part == 'llt':
			p = part.upper()
		else:
			p = part.rstrip('_spec.rb')
			p = ''.join([x.capitalize() for x in p.split('_')])
		corrected_parts.append(p)
	snip.rv = '::'.join(corrected_parts)

def pluralize(count, re):
	if not re.match('^\d+$', count):
		return ''

	count = int(count)
	return '' if count == 1 else 's'
endglobal

	
######### if and unless #########

snippet ? "ternary operator" w
${1:condition} ? ${2:true} : ${0:false}
endsnippet
	
snippet If "<command> if <expression>"
${1:command} if ${0:expression}
endsnippet

snippet Ul "<command> unless <expression>"
${1:command} unless ${0:expression}
endsnippet

snippet if "if <condition> ... end"
if ${1:condition}
	${2}
end
endsnippet

snippet ife "if <condition> ... else ... end"
if ${1:condition}
	${2}
else
	${3}
end
endsnippet

snippet ifee "if <condition> ... elseif <condition> ... else ... end"
if ${1:condition}
	${2}
elsif ${3:condition}
	${4}
else
	${0}
end
endsnippet

snippet ul "unless <condition> ... end"
unless ${1:condition}
	${0}
end
endsnippet

snippet ule "unless <condition> ... else ... end"
unless ${1:condition}
	${2}
else
	${0}
end
endsnippet

######### Method definitions #########

snippet "(de)?f" "def <name>" rb
def ${1:function_name}
  ${0}	
end
endsnippet

snippet "(de)?fa" "def <name>(*args)" rb
def ${1:function_name}(${2:*args})
	${0}	
end
endsnippet

snippet "(de)?fi" "def initialize ..." br
def initialize(${1:*args})
	${2:iva}
end
${0}
endsnippet

snippet "(de)?fs" "def self.<name>" br
def self.${1:class_method_name}
	${0}
end
endsnippet

snippet "(de)?fsa" "def self.<name>(*args)" rb
def self.${1:class_method_name}(3:*args)
	${0}
end
endsnippet


######### Loops and Begins #########

snippet defmm "method_missing" b
def method_missing(meth, *args, &blk)
	${0}
end
endsnippet

snippet until "until <expression> ... end"
until ${1:expression}
	${0}
end
endsnippet

snippet Until "begin ... end until <expression>"
begin
	${0}
end until ${1:expression}
endsnippet

snippet wh "while <expression> ... end"
while ${1:expression}
	${0}
end
endsnippet

snippet While "begin ... end while <expression>"
begin
	${0}
end while ${1:expression}
endsnippet

snippet beg "begin with rescue"
begin
	${0}
rescue ${1:Exception} => ${2:e}
end
endsnippet

snippet begin "begin ... rescue ... end"
begin
	${1}
rescue
	${0}
end
endsnippet

snippet begine "begin ... rescue ... else ... ensure ... end"
begin
	${1:# Raise exception}
rescue Exception => e
	puts e.message
	puts e.backtrace.inspect
	${2:# Rescue}
else
	${3:# other exception}
ensure
	${0:# always excute}
end
endsnippet

snippet rescue
rescue Exception => e
	puts e.message
	puts e.backtrace.inspect
	${0:# Rescue}
endsnippet


######### aliases #########
	
snippet al "al"
alias_method :${1:new_name}, :${0:old_name}
endsnippet

snippet alias "alias :<new_name> :<old_name>"
alias :${1:new_name} :${2:old_name}
endsnippet

snippet asloop "ArrayScanner loop"
loop do
  ${0}
  break if ${1:as}.eoa?
end
endsnippet


######### Case statements #########
	
snippet caset "Case with one line when then"
case ${1:obj}
when ${2:cond} then ${3:res}
${0:whent}
end
endsnippet

snippet whent "More when then lines"
when ${1:cond} then ${2:res}
${3:whent}
endsnippet

snippet case "case <variable> when <expression> ... end"
case ${1:variable}
when ${2:expression}
  $0
end
endsnippet

snippet when "when"
when ${1:condition}
	${0}
endsnippet

snippet toca "creates a one-liner case switch" !b
case ${1:obj} => $2 $0
`!p case_creator(t[1], t[2], snip)`

endsnippet
######### Instance variables #########
	
snippet iva "Instance variable assignment with mirroring"
@${1:iva} = $1
${0}
endsnippet

snippet iv "Plain instance variable assignment"
@${1} = ${0}
endsnippet

snippet ivc "Instance variable cache"
@${1:variable_name} ||= ${0:chached_value}
endsnippet

snippet ivcb "Instance variable cache (multiline)" !b
@${1:variable} ||= begin
  ${0:body}
end
endsnippet

######### %{} Expression #########

snippet ia "ia"
%i{ ${1:syms} }
endsnippet

snippet wa "wa"
%w{ ${1:elements} }
endsnippet

snippet qa "qa"
%Q{
  ${0}
}
endsnippet
	
######### Concerning Hashes #########

snippet eawodh "each_with_object coming from hash" w
each_with_object(${1}) do |(${2:k}, ${3:v}), ${4:v}|
  ${0}
end
endsnippet

snippet "ml?h" "multiline hash" r
${1:var} = {
  ${0}
}
endsnippet

snippet "toh(c?[si]?)" "creates a multiline hash" r
$1 = ${2:dot_delimits_key_and_value_two_spaces_pairs} $0
`!p hash_creator(t[1], t[2], match.group(1), snip)`
endsnippet

snippet "(hr|:)" "hashrocket" r
'${1}' => ${2},
${0::}
endsnippet

snippet hzip "Hash.new from zip"
Hash[${1}.zip(${2})]${0}
endsnippet

######### File Handling #########
	
snippet fexp "Expand file path"
File.expand_path(${1}, ${2:__FILE__})${0}
endsnippet

snippet fr "read a file"
File.read("${1}")${0}
endsnippet

snippet fo "file open with do end block"
File.open(${1}, '${2}') do
  ${0}
end
endsnippet

snippet fj "file join"
File.join(${1})${0}
endsnippet


######### RSpec #########

snippet spec "sets up a spec file"
require 'spec_helper'

describe ${1} do
  ${0}
end
endsnippet

snippet specm "sets up a spec file to test a module"
require 'spec_helper'

describe ${1:`!p spec_class_name(snip, path, re)`} do
  let(:dummy) { Class.new { include $1 } }

  ${0:desc}
end
endsnippet

snippet specc "sets up a spec file to test a class"
require 'spec_helper'

describe ${1:`!p spec_class_name(snip, path, re)`} do
  let(:${2:`!p snip.rv = snip.basename.rstrip('_spec.rb')`}) { $1.new${3:()} }

  ${0:desc}
end
endsnippet

snippet desc "describe instance method" !b
describe "#${1:method}" do
	${0:pending "not implemented"}
end
endsnippet

snippet descc "describe a class method" !b
describe ".${1:method}" do
	${0:pending "not implemented"}
end
endsnippet

snippet cont "context"
context "${1}" do
  ${0:it}
end
endsnippet

snippet it "it example" b
it "${1}" do
  ${2}
end

${0:it}
endsnippet

snippet stub "simple stub" w
stub(${1:method}: ${0:return})
endsnippet

snippet stubb "stubs a message with a block" w
stub(:${1}) { ${0} }
endsnippet

snippet stubd "stubs a message with a do end block"  w
stub(:${1}) do
  ${0}
end
endsnippet

snippet stubw "stubs message with explicit arguments"  w
stub(:${1}).with(${2}) { ${0} }
endsnippet

snippet stubwd "stubs message with explicit arguments and do end block" w
stub(:${1}).with(${2}) do
  ${0}
end
endsnippet

snippet dou "launches a spec double"
obj = double(${1})
${0}
endsnippet

snippet "capt?u?r?e?" "captures $stdout in spec files" r
before :all do
  string_io = StringIO.new
  @stdout = $stdout
  $stdout = string_io
end

${0}

after :all do
  $stdout = @stdout
end
endsnippet

snippet outr "what $stdout receives"
$stdout.should receive(:${1:puts})
endsnippet

snippet outrw "what $stdout receives explicitly"
$stdout.should receive(:puts).with(/${0}/)
endsnippet

snippet sbt "should be_true" w
should be_true
endsnippet

snippet sbf "should be_false" w
should be_false
endsnippet

snippet sbe "should be_empty" w
should be_empty
endsnippet

snippet sbn "should be_nil" w
should be_nil
endsnippet

snippet shi "should have item(s)" w
should have(${1}).item`!p snip.rv = pluralize(t[1], re)`$0
endsnippet

snippet se "should == " w
should == ${0}
endsnippet

snippet sm "should =~" w
should =~ ${0}
endsnippet

snippet sr "should receive" w
should receive(:${0})
endsnippet

snippet snr "should_not receive" w
should_not receive(:${0})
endsnippet

snippet srw "should receive with" w
should receive(:${1}).with(${0})
endsnippet

snippet srt "should respond_to" w
should respond_to(:${0})
endsnippet

snippet let "let {}"
let(:${1}) { ${2} }${0}
endsnippet

snippet letd "let do ... end"
let(:${1}) do
  ${2}
end${0}
endsnippet

snippet raise "expext to raise error"
expect { ${1:object} }.to raise_error ${2:StandardError}, /${0:message_regex}/
endsnippet

snippet exp "expect"
expect { ${1:object} }.to ${0}
endsnippet

snippet bef "bef"
before :${1:each} do
	${0}
end
endsnippet

snippet aft "aft"
after :${1:each} do
	${0}
end
endsnippet

######### LLT specific spec examples #########
	
snippet itm "itm"
it "${1}" do
  f = morphologizer.morphologize("${2}")
  f.should have(${3}).item${0}
end
endsnippet

snippet itpf "itpf"
it "like ${1}" do
  pf_composition("${2}", "${3}").should == "${4}"${0}
end
endsnippet

######### String handling #########

snippet ip "string interpolation" i
#{${1:interpolation}}${0}
endsnippet

snippet gsubb "gsub {}" w
gsub(/${2:pattern}/) { |${3:match}| ${0} }
endsnippet

######### Class level snippets #########

snippet "clas?s?" "A class with optional intialize" rb
class ${1}
  ${2:defi}
end
endsnippet

global !p
def complete_init_args(arg_string, indentation):
		indent = indentation + '    '
		args = arg_string.split(', ')
		vars = ['@%s = %s' % (var, var) for var in args if var]
    # first line already has proper indentation
		vars = [vars[0]] + [indent + var for var in vars[1:]]
		return '\n'.join(vars)
endglobal
	

snippet classi "class with auto instance variable setting" !b
class ${1:Class}
  def initialize(${2:args})
    `!p snip.rv = complete_init_args(t[2], snip._initial_indent)`
  end

  $0
end
endsnippet

snippet "scla?s?s?" "Switches context to singleton class" rb
class << self
  ${0:def}
end
endsnippet

snippet modc "Module with class and instance methods" b
module ${1}
  def self.included(obj)
    obj.extend(ClassMethods)
  end

  ${0}

  module ClassMethods
  end
end
endsnippet

snippet inc "Include with optional repetition" b
include ${1}
${0:inc}
endsnippet

snippet Enum "include Enumerable" b
include Enumerable

def each(&blk)
	${0}
end
endsnippet

snippet Forw "extend Forwardable" b
extend Forwardable
endsnippet

snippet Comp "include Comparabale" b
include Comparable

def <=>(other)
	${0}
end
endsnippet

snippet defd "def_delegator" b
def_delegator :${1:@del_obj}, :${2:del_meth}, :${0:new_name}
endsnippet

snippet defds "def_delegators" b
def_delegators :${1:@del_obj}, :${0:del_methods}
endsnippet

snippet pri "make the rest private" b
private

${0}
endsnippet

snippet r "attr_reader" b
attr_reader :${0:attr_names}
endsnippet

snippet w "attr_writer" b
attr_writer :${0:attr_names}
endsnippet

snippet rw "attr_accessor" b
attr_accessor :${0:attr_names}
endsnippet

snippet atp "attr_protected" b
attr_protected :${0:attr_names}
endsnippet

snippet ata "attr_accessible" b
attr_accessible :${0:attr_names}
endsnippet


######### Executables #########

snippet "^#!" "#!/usr/bin/env ruby" r
#!/usr/bin/env ruby
$0
endsnippet

snippet end "__END__"
__END__
endsnippet

snippet # "comment to indicate return value"
# =>
endsnippet

snippet app "if __FILE__ == .."
if __FILE__ == $PROGRAM_NAME
	${0}
end
endsnippet

snippet bin "ruby bin file with load path loading" b!
#!/usr/bin/env ruby

lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require '${0:`!p snip.rv = snip.basename`}'
endsnippet

snippet lp "adds lib folder to load" !b
lib = File.expand_path('${0:../..}/lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
endsnippet
	

######### Iterators #########

snippet b "{}"
{ |${1:var}| ${0} }
endsnippet

snippet ea "each {}" w
each { |${1:e}| ${0} }
endsnippet

snippet ead "each do .. end" w
each do |${1:e}|
	${0}
end
endsnippet

snippet eas "each_slice {}" w
each_slice(${1:2}) { |${2:group}| ${0} }
endsnippet

snippet easd "each_slice do ... end" w
each_slice(${1:2}) do |${2:group}|
	${0}
end
endsnippet
	
snippet eawi "each_with_index {}" w
each_with_index { |${1:e}, ${2:i}| ${0} }
endsnippet

snippet eawid "each_with_index do .. end" w
each_with_index do |${1:e}, ${2:i}|
	${0}
end
endsnippet

global !p
def complete_eawo(obj):
	returns = {'""' : 'str', "''" : 'str', '[]' : 'arr', '{}' : 'hsh'}
	return returns.get(obj, 'var')
endglobal

snippet ealwo "each_line.with_object do .. end" w
each_line.with_object(${1:''}) do  |line, ${2:`!p snip.rv = complete_eawo(t[1])`}|
  ${0}
end
endsnippet

snippet eawo "each_with_object {}" w
each_with_object(${1:{}}) { |${2:e}, ${3:`!p snip.rv = complete_eawo(t[1])`}| ${0} }
endsnippet

snippet eawod "each_with_object do .. end" w
each_with_object(${1:{}}) do |${2:e}, ${3:`!p snip.rv = complete_eawo(t[1])`}|
	${0}
end
endsnippet

snippet del "delete_if {}" w
delete_if { |${1:e}| ${0} }
endsnippet

snippet deld "delete_if do ... end" w
delete_if do |${1:e}|
  ${0}
end
endsnippet

snippet inj "inject {}" w
inject(${1:init}) { |${2:mem}, ${3:var}| ${0} }
endsnippet

snippet injd "inject do ... end" w
inject(${1:init}) do |${2:mem}, ${3:var}|
	${0}
end
endsnippet

snippet map "map {}" w
map { |${1:e}| ${0} }
endsnippet

snippet mapd "map do ... end" w
map do |${1}|
  ${0}
end
endsnippet

snippet mapp "map(&:method)" w
map(&:${1})${0}
endsnippet

snippet sor "sort {}" w
sort { |a, b| ${0} }
endsnippet

snippet sord "sort do end" w
sort do |a, b|
  ${0}
end
endsnippet

snippet sorb "sort_by {}" w
sort_by { |${1:e}| ${0} }
endsnippet

snippet sorbd "sort_by do ... end" w
sort_by do |${1:e}|
  ${0}
end
endsnippet

snippet tima "times { |n| }" w
times { |${1:n}| ${0} }
endsnippet

snippet timad "times do |n| ... end" w
times do |${1:n}|
  ${0}
end
endsnippet

snippet tim "times {}" w
times { ${0} }
endsnippet

snippet timad "times do ... end" w
times do
  ${0}
end
endsnippet

snippet all "all? {}" w
all? { |${1:e}| ${0} }
endsnippet

snippet alld "all? do ... end" w
all? do |${1:e}|
  ${0}
end
endsnippet

snippet any "any? {}" w
any? { |${1:e}| ${0} }
endsnippet

snippet anyd "any? do ... end" w
any? do |${1:e}|
  ${0}
end
endsnippet

snippet fin "find {}" w
find { |${1:e}| ${0} }
endsnippet

snippet find "find do ... end" w
find do |${1:e}|
	${0}
end
endsnippet

snippet par "partition {}" w
partition { |${1:e}| ${0} }
endsnippet

snippet pard "partition do ... end" w
partition do |${1:e}|
	${0}
end
endsnippet

snippet rej "rejecct {}" w
reject { |${1:e}| ${0} }
endsnippet

snippet rejd "reject do ... end" w
reject do |${1:e}|
	${0}
end
endsnippet

snippet sel "select {}" w
select { |${1:e}| ${0} }
endsnippet

snippet seld "select do ... end" w
select do |${1:e}|
	${0}
end
endsnippet

snippet do "do |v| end" w
do |${1:v}|
	${2}
end
endsnippet

snippet lam "lambda {}"
lambda { |${1:args}| ${0} }
endsnippet

snippet lam "lambda do ... end"
lambda do |${1:args}|
  ${0}
end
endsnippet

######### LLT Snippets #########
	
snippet llt "the llt module" 
module LLT
  ${0}
end
endsnippet

snippet lltc "llt module with a class"
module LLT
  class ${1}
    ${2:defi}
  end
end
endsnippet

snippet lltm "lltc module with another module"
module LLT
  module ${1}
    ${0}
  end
end
endsnippet

######### Regexp helpers #########
	
snippet lb "look-behind"
(?<=${1})${0}
endsnippet

snippet nlb "negative look-behind"
(?<!${1})${0}
endsnippet

snippet la "look-ahead" i
(?=${1})${0}
endsnippet

snippet nla "negative look-ahead" i
(?!${1})${0}
endsnippet

snippet ma "match method" w
match(/${0}/)
endsnippet

snippet scan "scan with regexp" w
scan(/${1:regexp}/)$0
endsnippet

snippet mab "match method with beginning and end (^$)" w
match(/^${0}$/)
endsnippet

snippet rbe "regular expression beginning and end (^$" w
/^${0}$/
endsnippet

######### Rake #########
	
snippet "ta?sk" "rake task" !br
desc '${1}'
task :${2} do
  ${0}
end
endsnippet

snippet "ta?ska" "rake task with arguments" !br
desc '${1}'
task :${2} do |t, args|
  ${0}
end
endsnippet

snippet ns "rake namespace" !b
namespace :${1} do
  ${0}
end
endsnippet

######### Gemfile #########
	
snippet gem "a gem chain" !b
gem '${1}'
${0:gem}
endsnippet

snippet gemg "git gem git" !b
gem '${1}', git: 'git://github.com/${2:USER}/${3:$1}.git'
${0:gemg}
endsnippet

snippet geml "local gem" !b
gem '${1}', path: '${2}'
${0:geml}
endsnippet

snippet gemr "gem with a require statement" !b
gem '${1}', require: ${2}
${0:gemr}
endsnippet

snippet "gemp([rj])?" "Platform dependent gem" !br
gem '${1}', platform: :`!p snip.rv =  'j' if match.group(1) == 'j' else ''`ruby
endsnippet

snippet "pl([rj])?" "Platform block" !br
platform :`!p snip.rv =  'j' if match.group(1) == 'j' else ''`ruby do
  ${0:gem}
end
endsnippet

######### Thor #########

snippet mo "method_option with an alias and repetition" !b
method_option :${1:option}, aliases: '-${1/(\w).*/$1/}',
  desc: '${2:description}'
${0:mo}
endsnippet

snippet thor "a full Thor command" !b
desc '${1:method}', '${2:description}'
${3:mo}
def $1${4:(${5:var})}
  $0
end
endsnippet

######### OptionParser #########

snippet opparser "Description" !
OptionParser.new do |opts|
  opts.banner "${1:`!p snip.rv = snip.basename`}"
  opts.separator ''
  ${0:opt}
end
endsnippet

snippet op "opts.on" !
opts.on('-${1/(\w).*/$1/}', '--${1:option}', '${2:description}') do |${3:$1}|
  $0
end
endsnippet
	
snippet opsep "opts.separator" !
opts.separator '$0'
endsnippet

snippet oph "opts.on <help>" !
opts.on('-h', '--help', 'Displays this help')
endsnippet
	
######### Environmental Variables #########
	
snippet env "env variable access"
ENV['${1:HOME}']${0}
endsnippet


######### Requiring #########

snippet req "simple require with repetition" !b
require '${1}'
${0:req}
endsnippet

snippet reqr "require relative with repetition" !b
require_relative '${1}'
${0:reqr}
endsnippet

######### Sinatra #########

snippet sin "sinatra modular setup" !b
require 'sinatra/base'

class ${1} < Sinatra::Base
  ${0}
end
endsnippet

snippet sget "sinatra get"
get '/${1}' do
  ${0}
end
endsnippet

######### Param and options handling #########

snippet p "accessing params"
params[:${1}]${0}
endsnippet	

snippet pe "extract param to variable"
${1} = params[:$1]${0}
endsnippet

snippet o "accessing options"
options[:${1}]${0}
endsnippet

snippet oe "extract option to variable"
${1} = options[:$1]${0}
endsnippet


######### Rails #########

# More to come later

### Migrations

snippet mac "Migrations: add_column"
add_column :${1:table_name}, :${2:column_name}, :${0:data_type}
endsnippet

snippet mai "Migrations: add_index"
add_index :${1:table_name}, :${0:column_name}
endsnippe	
snippet mrc "Migrations: remove_column"
remove_column :${1:table_name}, :${0:column_name}
endsnippet

snippet mrnc "Migrations: rename_column"
rename_column :${1:table_name}, :${2:old_column_name}, :${0:new_column_name}
endsnippet

snippet mcc "Migrations: change_column"
change_column :${1:table}, :${2:column}, :${0:type}
endsnippet

######### various #########

snippet todo "TODO"
# TODO `!v strftime("%d.%m.%y %H:%M")` by LFDM
# ${1}
endsnippet

snippet pry "pry"
require 'pry'; binding.pry
endsnippet
	

######### RAILS UNMAINTAINED #########

#snippet bf "bf"
#before_filter :${0:method}
#endsnippet

#snippet bt "bt"
#belongs_to :${0:association}
#endsnippet

#snippet btp "btp"
#belongs_to :${1:association}, :polymorphic => true
#endsnippet

#snippet crw "crw"
#cattr_accessor :${0:attr_names}
#endsnippet

#snippet defcreate "defcreate"
#def create
	#@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])
	#respond_to do |format|
		#if @$1.save
			#flash[:notice] = '$2 was successfully created.'
			#format.html { redirect_to(@$1) }
			#format.xml  { render :xml => @$1, :status => :created, :location => @$1 }
		#else
			#format.html { render :action => "new" }
			#format.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
		#end
	#end
#end
#endsnippet

#snippet defdestroy "defdestroy"
#def destroy
	#@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	#@$1.destroy
	#respond_to do |format|
		#format.html { redirect_to($1s_url) }
		#format.xml  { head :ok }
	#end
#end
#endsnippet

#snippet defedit "defedit"
#def edit
	#@${1:model_class_name} = ${0:ModelClassName}.find(params[:id])
#end
#endsnippet

#snippet defindex "defindex"
#def index
	#@${1:model_class_name} = ${2:ModelClassName}.all
	#respond_to do |format|
		#format.html # index.html.erb
		#format.xml  { render :xml => @$1s }
	#end
#end
#endsnippet

#snippet defnew "defnew"
#def new
	#@${1:model_class_name} = ${2:ModelClassName}.new
	#respond_to do |format|
		#format.html # new.html.erb
		#format.xml  { render :xml => @$1 }
	#end
#end
#endsnippet

#snippet defshow "defshow"
#def show
	#@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	#respond_to do |format|
		#format.html # show.html.erb
		#format.xml  { render :xml => @$1 }
	#end
#end
#endsnippet

#snippet defupdate "defupdate"
#def update
	#@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	#respond_to do |format|
		#if @$1.update_attributes(params[:$1])
			#flash[:notice] = '$2 was successfully updated.'
			#format.html { redirect_to(@$1) }
			#format.xml  { head :ok }
		#else
			#format.html { render :action => "edit" }
			#format.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
		#end
	#end
#end
#endsnippet

#snippet dele "delegate .. to"
#delegate :${1:methods}, :to => :${0:object}
#endsnippet

#snippet dele "delegate .. to .. prefix .. allow_nil"
#delegate :${1:methods}, :to => :${2:object}, :prefix => :${3:prefix}, :allow_nil => ${0:allow_nil}
#endsnippet

#snippet flash "flash"
#flash[:${1:notice}] = "${0}"
#endsnippet

#snippet habtm "habtm"
#has_and_belongs_to_many :${1:object}, :join_table => "${2:table_name}", :foreign_key => "${3}_id"
#endsnippet

#snippet hm "hm"
#has_many :${0:object}
#endsnippet

#snippet hmd "hmd"
#has_many :${1:other}s, :class_name => "${2:$1}", :foreign_key => "${3:$1}_id", :dependent => :destroy
#endsnippet

#snippet hmt "hmt"
#has_many :${1:object}, :through => :${0:object}
#endsnippet

#snippet ho "ho"
#has_one :${0:object}
#endsnippet

#snippet hod "hod"
#has_one :${1:object}, dependent: :${0:destroy}
#endsnippet

#snippet i18 "i18"
#I18n.t('${1:type.key}')
#endsnippet

#snippet ist "ist"
#<%= image_submit_tag("${1:agree.png}", :id => "${2:id}"${0} %>
#endsnippet

#snippet log "log"
#Rails.logger.${1:debug} ${0}
#endsnippet

#snippet log2 "log2"
#RAILS_DEFAULT_LOGGER.${1:debug} ${0}
#endsnippet

#snippet logd "logd"
#logger.debug { "${1:message}" }
#endsnippet

#snippet loge "loge"
#logger.error { "${1:message}" }
#endsnippet

#snippet logf "logf"
#logger.fatal { "${1:message}" }
#endsnippet

#snippet logi "logi"
#logger.info { "${1:message}" }
#endsnippet

#snippet logw "logw"
#logger.warn { "${1:message}" }
#endsnippet

#snippet mapc "mapc"
#${1:map}.${2:connect} '${0:controller/:action/:id}'
#endsnippet

#snippet mapca "mapca"
#${1:map}.catch_all "*${2:anything}", :controller => "${3:default}", :action => "${4:error}"
#endsnippet

#snippet mapr "mapr"
#${1:map}.resource :${0:resource}
#endsnippet

#snippet maprs "maprs"
#${1:map}.resources :${0:resource}
#endsnippet

#snippet mapwo "mapwo"
#${1:map}.with_options :${2:controller} => '${3:thing}' do |$3|
	#${0}
#end
#endsnippet

#snippet mbs "mbs"
#before_save :${0:method}
#endsnippet

#snippet mcht "mcht"
#change_table :${1:table_name} do |t|
	#${0}
#end
#endsnippet

#snippet mp "mp"
#map(&:${0:id})
#endsnippet

#snippet mrw "mrw"
#mattr_accessor :${0:attr_names}
#endsnippet

#snippet oa "oa"
#order("${0:field}")
#endsnippet

#snippet od "od"
#order("${0:field} DESC")
#endsnippet

#snippet pa "pa"
#params[:${1:id}]
#endsnippet

#snippet ra "ra"
#render :action => "${0:action}"
#endsnippet

#snippet ral "ral"
#render :action => "${1:action}", :layout => "${0:layoutname}"
#endsnippet

#snippet rest "rest"
#respond_to do |format|
	#format.${1:html} { ${0} }
#end
#endsnippet

#snippet rf "rf"
#render :file => "${0:filepath}"
#endsnippet

#snippet rfu "rfu"
#render :file => "${1:filepath}", :use_full_path => ${0:false}
#endsnippet

#snippet ri "ri"
#render :inline => "${0:<%= 'hello' %>}"
#endsnippet

#snippet ril "ril"
#render :inline => "${1:<%= 'hello' %>}", :locals => { ${2::name} => "${3:value}"${0} }
#endsnippet

#snippet rit "rit"
#render :inline => "${1:<%= 'hello' %>}", :type => ${0::rxml}
#endsnippet

#snippet rjson "rjson"
#render :json => ${0:text to render}
#endsnippet

#snippet rl "rl"
#render :layout => "${0:layoutname}"
#endsnippet

#snippet rn "rn"
#render :nothing => ${0:true}
#endsnippet

#snippet rns "rns"
#render :nothing => ${1:true}, :status => ${0:401}
#endsnippet

#snippet rp "rp"
#render :partial => "${0:item}"
#endsnippet

#snippet rpc "rpc"
#render :partial => "${1:item}", :collection => ${0:@$1s}
#endsnippet

#snippet rpl "rpl"
#render :partial => "${1:item}", :locals => { :${2:$1} => ${0:@$1}
#endsnippet

#snippet rpo "rpo"
#render :partial => "${1:item}", :object => ${0:@$1}
#endsnippet

#snippet rps "rps"
#render :partial => "${1:item}", :status => ${0:500}
#endsnippet

#snippet rt "rt"
#render :text => "${0:text to render}"
#endsnippet

#snippet rtl "rtl"
#render :text => "${1:text to render}", :layout => "${0:layoutname}"
#endsnippet

#snippet rtlt "rtlt"
#render :text => "${1:text to render}", :layout => ${0:true}
#endsnippet

#snippet rts "rts"
#render :text => "${1:text to render}", :status => ${0:401}
#endsnippet

#snippet ru "ru"
#render :update do |${1:page}|
	#$1.${0}
#end
#endsnippet

#snippet rxml "rxml"
#render :xml => ${0:text to render}
#endsnippet

#snippet sc "sc"
#scope :${1:name}, -> { where(${2:field}: ${0:value}) }
#endsnippet

#snippet sl "sl"
#scope :${1:name}, lambda do |${2:value}|
	#where("${3:field = ?}", ${0:bind var})
#end
#endsnippet

#snippet sha1 "sha1"
#Digest::SHA1.hexdigest(${0:string})
#endsnippet

#snippet sweeper "sweeper"
#class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper
	#observe $1
	#def after_save(${0:model_class_name})
		#expire_cache($2)
	#end
	#def after_destroy($2)
		#expire_cache($2)
	#end
	#def expire_cache($2)
		#expire_page
	#end
#end
#endsnippet

#snippet va "validates_associated"
#validates_associated :${0:attribute}
#endsnippet

#snippet va "validates .., :acceptance => true"
#validates :${0:terms}, :acceptance => true
#endsnippet

#snippet vc "vc"
#validates :${0:attribute}, :confirmation => true
#endsnippet

#snippet ve "ve"
#validates :${1:attribute}, :exclusion => { :in => ${0:%w( mov avi )} }
#endsnippet

#snippet vf "vf"
#validates :${1:attribute}, :format => { :with => /${0:regex}/ }
#endsnippet

#snippet vi "vi"
#validates :${1:attribute}, :inclusion => { :in => %w(${0: mov avi }) }
#endsnippet

#snippet vl "vl"
#validates :${1:attribute}, :length => { :in => ${2:3}..${0:20} }
#endsnippet

#snippet vn "vn"
#validates :${0:attribute}, :numericality => true
#endsnippet

#snippet vp "vp"
#validates :${0:attribute}, :presence => true
#endsnippet

#snippet vu "vu"
#validates :${0:attribute}, :uniqueness => true
#endsnippet

#snippet format "format"
#format.${1:js|xml|html} { ${0} }
#endsnippet

#snippet wc "wc"
#where(${1:"conditions"}${0:, bind_var})
#endsnippet

#snippet wf "wf"
#where(${1:field} => ${0:value})
#endsnippet

#snippet xdelete "xdelete"
#xhr :delete, :${1:destroy}, :id => ${2:1}
#endsnippet

#snippet xget "xget"
#xhr :get, :${1:show}, :id => ${2:1}
#endsnippet

#snippet xpost "xpost"
#xhr :post, :${1:create}, :${2:object} => { ${0} }
#endsnippet

#snippet xput "xput"
#xhr :put, :${1:update}, :id => ${2:1}, :${3:object} => { ${4} }
#endsnippet
